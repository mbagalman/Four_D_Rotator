from __future__ import annotations
# That HAS to be first.

""
"""
Wavefront OBJ exporter for *tesseract_slice* slices.

Keeps file-writing logic isolated from the math core so geometry modules
stay IO‑free.

Author: Michael Bagalman
License: MIT
"""

# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Michael Bagalman

import time
from pathlib import Path
from typing import List, Tuple, Union

import numpy as np

from ._constants import SHAPE_NAMES

# Type aliases
Edge = Tuple[np.ndarray, np.ndarray]

__all__ = ["export_to_obj"]


# ---------------------------------------------------------------------------
# Helper
# ---------------------------------------------------------------------------

def _vertex_key(v: np.ndarray, decimals: int = 6) -> Tuple[float, float, float]:
    """Rounded tuple for hashing float coordinates.

    Rounding helps combat floating point jitter when matching coordinates
    to their indices in the .obj format.
    """
    return tuple(np.round(v, decimals))  # type: ignore[arg-type]


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def export_to_obj(
    vertices: np.ndarray,
    edges: List[Edge],
    filename: Union[str, Path],
    *,
    include_metadata: bool = True,
) -> None:
    """Write slice geometry to a Wavefront ``.obj`` file.

    Parameters
    ----------
    vertices
        ``(N, 3)`` array of 3‑D vertices.
    edges
        List of ``(v1, v2)`` vertex pairs.  Faces are *not* exported because
        all slices are convex and educators often want the wireframe.
    filename
        Output path (should end with ``.obj``).
    include_metadata
        If ``True`` the file starts with helpful comment lines.
    """

    path = Path(filename).with_suffix(".obj")

    # --- header ------------------------------------------------------------
    lines: List[str] = []
    if include_metadata:
        lines.extend(
            [
                "# Tesseract slice generated by tesseract_slice",
                f"# Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}",
                f"# Vertices: {len(vertices)}",
                f"# Edges: {len(edges)}",
                f"# Shape: {SHAPE_NAMES.get(len(vertices), 'unknown')}",
                "",
            ]
        )

    # --- vertices ----------------------------------------------------------
    for v in vertices:
        lines.append(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}")

    # --- edge indices ------------------------------------------------------
    # Build mapping from coordinate → 1‑based OBJ index
    index_lookup = {_vertex_key(v): i + 1 for i, v in enumerate(vertices)}

    lines.append("\n# Edges")
    for p, q in edges:
        i1 = index_lookup.get(_vertex_key(p))
        i2 = index_lookup.get(_vertex_key(q))

        # Edge validation: only write edge if both points match known vertices
        if i1 and i2 and i1 != i2:
            lines.append(f"l {i1} {i2}")
        else:
            # This should not happen with valid geometry but is worth flagging
            # if edges come from an external or transformed source.
            continue  # You may wish to log a warning here in a larger app

    # --- write file --------------------------------------------------------
    path.write_text("\n".join(lines))
